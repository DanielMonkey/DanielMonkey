Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-03-21T18:25:22+08:00

====== 09 C++ storage type ======
Created Thursday 21 March 2019

存储类定义C++程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。
下面列出C++程序中可用的存储类：
* auto
* register
* static
* extern
* mutable
* thread_local (C++11)

从C++ 11开始，auto关键字不再是C++存储类说明符，且register关键字被弃用。

auto存储类
自C++ 11以来，auto关键字用于两种情况：
声明变量时根据初始化表达式自动判断该变量的类型、声明函数时函数返回值的占位符。
C++ 98标准中auto关键字用于自动变量的生命，但由于使用极少且多余，在C++ 11中已删除这一用法。

register存储类
register存储类用于定义存储在寄存器中而不是RAM中的局部变量。
这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的'&'运算符（因为它没有内存位置）。
寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义'register'并不意味着变量将被村村在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

static 存储类
static存储类指示编译器的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用static修饰局部变量可以在函数调用之间保持局部变量的值。
static修饰符也可以应用于全局变量。当static修饰全局变量时，会使变量的作用域限制在声明它的文件内。
在C++中，当static用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

extern存储类
extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
当你使用'extern'时，对于无法初始化的变量，会吧变量名指向一个之前定义过的存储位置。
当你有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到已定义的变量或函数的引用。可以这么理解，extern是用来在另一个文件中声明一个全局变量或函数。
extern修饰符通常用于两个或多个文件共享相同的全局变量或函数的时候。

mutable存储类
mutable说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，mutable成员可以通过const成员函数修改。

thread_local存储类
使用thread_local说明符声明的变量仅可在它在其上创建的线程上访问。
变量在创建线程时创建，并在销毁线程时销毁。每个线程都有其自己的变量副本。
thread_local说明符可以与static或extern合并。
可以将thread_local仅应用于数据声明和定义，thread_local不能用于函数声明或定义。




































